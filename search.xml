<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6实用教程]]></title>
    <url>%2F2019%2F01%2F03%2FES6%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文讲解ES6实用教程，主要列举很多常用的ES6语法。 一、ES6的概念ES6是 新一代的JS语言标准，包含ES2015、ES2016、ES2017、ES2018等。ES2015特指在2015年发布的新一代JS语言标准，现阶段在绝大部分情景下，ES2015默认为ES6。ES2015可以理解为ES5和ES6的时间分界线。 二、变量声明ES5里面var没有块级作用域，这样一来，会导致很多问题。例如for循环变量泄露，变量覆盖，变量提升等问题。ES6用let来声明变量，let声明的变量拥有自己的块级作用域。 1234&#123; var a = 1;&#125;console.log(a); //1 1234&#123; let b = 2;&#125;console.log(b); //undefined 三、String字符串ES6新增了字符串模板语法，在拼接字符串时，用` 字符串 `的形式，同时能保留所有空格和换行。除此之外，还能在字符串中嵌入变量。`字符串${变量名}字符串`。取代了ES5中用加号+进行字符串进行相加。语法改进：123let age = 11;let str = `xiao ming is $&#123;age&#125; years old`;console.log(str); //xiao ming is 11 years old; 新的方法：ES6在原型上新增了Includes()方法，取代传统indexOf()查找字符串的方法。includes():找得到返回true，找不到返回false。indexOf():找得到返回0，找不到返回1。此外，还新增了startsWith()，endsWith()，padStart()，padEnd()，repeat()等方法，可用于查找，补全字符串。 12let str = `xiao ming`;console.log(str.includes(`xiao`)); //true 四、Array数组数组解构赋值声明较多变量时，不用写很多的let变量声明关键字。 1let [a,b,c,d] = [1,2,3,4]; //a=1,b=2,c=3,d=4 扩展运算符ES6新增的扩展运算符(…),可以实现数组和松散序列的相互转化，可以轻松取代arguments对象和apply方法，轻松获取未知参数个数情况下的参数集合。ES5中的arguments并不是真正的数组，而是一个类数组对象，但是运用扩展运算符的逆运算可以返回一个真正的数组。 12345//ES5function fun()&#123; console.log(arguments);&#125;fun(); //&#123; &apos;0&apos;: [ 1, 2, 3, 4 ] &#125; 12345//ES6function fun()&#123; console.log(...arguments);&#125;fun(); //[ 1, 2, 3, 4 ] 还可以实现数组的复制和解构赋值。123let arr = [2,3,4];let b = [...a]; console.log(b); //[2,3,4] 五、Number类型ES6在原型上新增了isFinite()，isNaN()方法。ES5中全局方法isFinite()，isNaN()，都会将非数值类型的参数转化为Number类型再做判断。ES中isNaN()的不足，”NaN”是一个字符串，但是返回的是true，意味着是NaN。1isNaN(&quot;NaN&quot;) === true; //true 1Number.isNaN(&quot;NaN&quot;) === true; //false ES6在Math对象上新增了Math.cbrt()，trunc()，hypot()等等较多的科学计数法运算方法，可以更全面的进行立方根、求和立方根等等科学计算。 六、Object类型a.对象属性变量式声明。ES6可以直接以变量形式声明对象属性或者方法。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰。 1234let [apple,orange] = [&quot;little apple&quot;,&quot;big orange&quot;];console.log(apple); //&quot;little apple&quot;let fruit = &#123;apple,orange&#125;; console.log(fruit); //&#123; apple: &apos;little apple&apos;, orange: &apos;big orange&apos; &#125; b.尤其在对象解构赋值或者模块输出变量时，更能体现好处： 12345let Object = &#123;apple:&apos;little apple&quot;, orange:&quot;big orange&quot;, banana::&quot;middle banana&quot;&#125;;let &#123;apple,orange,banana&#125; = Object;console.log(apple); //&quot;little apple&quot;let fruit = &#123;apple,orange,banana&#125;;console.log(fruit); //&#123;apple:&apos;little apple&quot;, orange:&quot;big orange&quot;, banana::&quot;middle banana&quot;&#125;; 可以看到属性变量式声明属性看起来更加简洁明了。方法也可以简洁写法： 123456let es5Obj = &#123; method: function() &#123;&#125;&#125;let es6Obj = &#123; method()&#123;&#125;&#125; c.对象的扩展运算符（…）ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也是特殊的对象。对象扩展运算符的用处在于可以轻松取出一个目标对象内部全部或者部分的可遍历属性，实现对象的合并和分解。 1234let &#123;apple, ...otherFruit&#125; = &#123;apple:&apos;little apple&quot;, orange:&quot;big orange&quot;, banana::&quot;middle banana&quot;&#125;;console.log(otherFruit); //&#123;orange:&quot;big orange&quot;, banana::&quot;middle banana&quot;&#125;;let moreFruits = &#123;peak: &quot;peak&quot;&#125;;let allFruit = &#123;apple, ...otherFruit,...moreFruits&#125;; d.ES6在Object原型上新增is()方法，比较两个目标对象，用来完善“===”方法。 12NaN === NaN //falseObject.is(NaN,NaN); //true e.ES6在Object原型上新增了assign()方法，用于对象新增属性或者多个对象合并。 12345const target = &#123;a:1&#125;;const source1 = &#123;b:2&#125;;const source2 = &#123;c:3&#125;;Object.assign(target,source1,source2);console.log(target); //&#123;a:1,b:2,c:3&#125; assign合并的对象target只能合并source1、source2中的自身属性，并不会合并source1、source2中的继承属性，也不会合并不可枚举属性，且无法正确复制get和set属性（会直接执行get/set函数，取return值）。 f.ES6在原型上新增了getOwnPropertyDescriptors()方法，增强了ES5的相同方法，可以获取指定对象所有自身属性的描述对象。结合defineProperties()方法，可以完美复制对象，包括复制get和set属性。 g.ES6在原型对象上新增了getPrototypeOf()和setPrototyprOf()方法，用来获取或设置当前对象的原型prototype对象。 h.ES6在Object原型上新增了Object.keys()，Object.values()，Object.entires()方法，用来获取对象的所有键、所有值和所有键值对数组。 七、Function函数类型a.箭头函数ES6箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象。箭头函数背部没有自己的this，this总是指向上一层的this，层层递上，直到找到有自己的this函数为止。ES5函数里的this总是指向函数执行时所在的对象，尤其在非严格模式下，this有时候会指向全局对象。 b.箭头函数不能用构造函数，因为它没有自己的this，无法实例化。 c.箭头函数没有自己的this，所以函数内也不存在arguments对象。这里就可以ES6的扩展运算符来代替。 d.函数的默认赋值ES5，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。ES6，函数可以默认赋值。 123456789function es6Fun(a = 1,b = 2,c = 3)&#123; console.log(a,b,c);&#125;es6Fun(); //1,2,3function es6Fun1(a,b = &quot;default&quot;)&#123; console.log(a,b);&#125;es6Fun1(&quot;666&quot;); //&quot;666&quot;,&quot;default&quot;es6Fun1(1,2); //1,2 e.ES6新增了双冒号运算符，用来取代以往的bind，call，和apply。 123456//ES5bar.bind(foo);bar.apply(foo,arguments);//ES6foo::bar;foo::bar(...arguements); 八、Symbol类型Symbol是ES6引入的第七种原始数据类型，所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。Symbol值通过Symbol函数生成。对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种是新增的symbol类型，凡是属性名属于symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。12let s = Symbol();typeof s //&apos;symbol&apos; Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12345678let s1 = Symbol(&apos;foo&apos;);let s2 = Symbol(&apos;bar&apos;);s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // &quot;Symbol(foo)&quot;s2.toString() // &quot;Symbol(bar)&quot; s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。 1234567891011// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol(&apos;foo&apos;);let s2 = Symbol(&apos;foo&apos;);s1 === s2 // false Symbol 值不能与其他类型的值进行运算，会报错。Symbol 值可以显式转为字符串。另外，Symbol 值也可以转为布尔值，但是不能转为数值。 作为属性名的symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = &apos;Hello!&apos;;// 第二种写法let a = &#123; [mySymbol]: &apos;Hello!&apos;&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot; Symbol 值作为对象属性名时，不能用点运算符。在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 对象中Symbol()属性不能被for…in遍历，但是也不是私有属性。 九、Set，类似Array的新的数据结构、Set是ES6引入的一种类似Array的新的数据结构，Set实例的成员类似于数组item的成员。区别：Set实例的成员都是唯一的，不重复的。这个特性可以轻松实现数组去重。简单来说，本质是数组，最核心就是数组去重。1234567891011let array = [1,2,3,2,3]；let set = new Set(array);console.log(set); //[1,2,3]let o1 = &#123;age:11&#125;let o2 = &#123;age:12&#125;let set = new Set([o1,o2]);console.log(set); //结果里面有两个对象吧，因为对象的内存地址不一样let o2 = o1;let set = new Set([o1,o2]);console.log(set); //结果里面有一个对象,对象的内存地址一样 当然，Set也有自己的属性和方法。 1234属性 .size 返回set集合的大小方法 .add()&lt;相当于数组的push()&gt; .delete(value) .has(value) .clear()清除数组 Set也可以转换为数组。12let array = Array.from(set); 遍历Set和遍历Array一样。 1234let set = new Set([1,2,3,3,4]);for(let v of set)&#123; console.log(v);&#125; 十、Map，类似Object的新的数据结构Map是ES6引入的一种类似Object的新的数据结构，Map可以理解为是Object的超集，打破了以传统键值对形式定义对象，对象的key不再局限于字符串，也可以是Object。 123456789101112131415161718let map1 = new Map()let obj = &#123;name:&apos;tiger&apos;&#125;map1.set(obj,&apos;hello0&apos;) //设置键值对map1.set(1,&apos;hello1&apos;)map1.set(2,&apos;hello2&apos;)alert(map1.get(obj)); //取值get//遍历键值对for(let item of map1)&#123; console.log(item);&#125;//遍历键for(let item of map1.keys())&#123; console.log(item);&#125;//遍历值for(let item of map1.value())&#123; console.log(item);&#125; 十一、Promise对象Promise是ES6引入的一个对象，主要作用是来解决JS异步机制里，回调机制产生的“回调地狱”。使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用。 12345678910111213141516function ajaxPromise() &#123; return new Promise(function(reslove,reject) &#123; console.log(&quot;正在执行...&quot;); if(true) &#123; reslove(&quot;success&quot;) &#125;else&#123; reject(&quot;fail&quot;) &#125; &#125;) &#125;ajaxPromise().then(value =&gt; &#123; console.log(value);&#125;).catch(err =&gt; &#123; console.log(err);&#125;) 更详细的讲解可参考：https://www.jianshu.com/p/c98eb98bd00c 十二、Generator函数执行Generator函数会返回一个遍历器对象，每一次Generator函数里面的yield都相当一次遍历器对象的next()方法，并且可以通过next(value)方法传入自定义的value，来改变Generator函数的行为。定义函数的时候需要加上星号,例：function test(){}函数体里面包含yield(暂停执行的标志),代码运行到yield的时候便会暂停执行，然后通过.next()，让代码继续执行，直到下一个yield或者函数体结束符。 12345678910111213function * test()&#123; let n = 0; n++; console.log(n); yield n;//产出 n++; console.log(n); yield n;//产出 return n;&#125; let test = test();test.next();text.next(); 十三、async函数async函数可以理解为内置自动执行器的Generator函数语法糖，它配合ES6的Promise近乎完美的实现了异步编程解决方案。 将generator的*替换成async,yield替换成await；await返回的是promise对象，或者是promise对象的resolve方法；async函数里面的return返回的也是promise对象，所以执行结果也是用.then接收返回值；await在async函数内部，但不能嵌套在其它函数的内部； 案例情景：如果async函数内部有多个await操作时，如果其中某个await出错，代码就无法继续执行，相当于break操作;try{…}catch(e){…}finally{…}将所有await操作放在try内部，结果还是当其中某个await出错的时候，try内的代码还是无法继续执行，但是try外的代码会继续执行；所以当有多个请求的时候，可以利用for循环，循环多个await操作，这样即使其中某个await操作出错，不会影响其他代码的执行；12async function fun()&#123;&#125; 十四、Class、extendsES6的class可以看作只是一个ES5生成实例对象的构造函数的语法糖。它参考了Java语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。Class类可以通过extends实现继承。它和ES5构造函数的不同点：a.类的内部定义的所有方法，都是不可枚举的。b.ES6的class类必须用new命令来操作，而ES5的构造函数不用new也可以执行。c.ES6的class类不存在变量提升，必须先定义class之后才能实例化，不像ES5中可以将构造函数写在实例化之后。d.ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。e.在class里面定义的方法都是原型链上，都是属于原型属性.f.实例的属性除非显式定义在其本身(即定义在this对象上)，否则都是定义在原型上(即定义在class上) 123456789101112//ES5function ES5Fun(a,b) &#123; this.a = a; this.b = b;&#125;ES5Fun.prototype.toString = function() &#123; return `($&#123;this.a&#125;,$&#123;this.b&#125;)`;&#125;let e = new ES5Fun(1,2);e.toString(); //(1,2);Object.keys(ES5Fun.prototype); //[&apos;toString&apos;] 123456789101112//ES6class ES6Fun&#123; constructor(a,b) &#123; this.a = a; this.b = b; toString() &#123; return `($&#123;this.a&#125;,$&#123;this.b&#125;)`; &#125;&#125;Object.keys(ES6Fun.prototype); //[],class内定义的方法都是不可枚举属性Object.getOwnPropertyNames(ES6Fun.prototype) //[&quot;constructor&quot;, &quot;toString&quot;],返回所有方法属性Object.hasOwnProperty(&quot;方法名“）; //实例属性返回true，继承属性返回false.class内都返回false,因为都是定义在原型上，而非实例上 十五、模块化开发为什么要模块化开发呢？有两个作用，其一，解决模块中函数名重复的问题；其二，解决模块之间的依赖关系。可以取代commonJS和AMD规范，实现浏览器和服务器的统一。自动开启严格模式，在每个模块头部自动添加“use strict“。export用于导出模块，import用于导入模块。例子：假设在同目录下有a.js和b.js这两个js文件123456789a.jsexport let sum = ((x,y) =&gt; &#123; return x + y;&#125;);export let minus= ((x,y) =&gt; &#123; return x - y;&#125;); 123456789101112b.js第一种引用方法：import &#123;sum,minus&#125; from &apos;./a.js&apos;;console.log(`sum:$&#123;sum(1,3)&#125;`); //4console.log(`minus:$&#123;minus(10,2)&#125;`) //8第二种引用方法：import * as util from &apos;./a.js&apos;;console.log(`util.sum:$&#123;util.sum(1,3)&#125;`); //4console.log(`util.minus:$&#123;util.minus(1,3)&#125;`); //8]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端模块化：CommonJS,AMD,CMD,ES6]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9ACommonJS-AMD-CMD-ES6%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文主要讲解前端模块化，其中包括CommonJS,AMD,CMD,ES6模块化。 一、模块化开发为什么要模块化开发呢？其一，解决模块中函数名重复的问题；其二，解决模块之间的依赖关系。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。具体可以参考阮一峰老师的文章：module-loader 二、CommonJSNode.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。 1234567891011121314151617// 定义模块math.jsvar basicNum = 0;function add(a, b) &#123; return a + b;&#125;module.exports = &#123; //在这里写上需要向外暴露的函数、变量 add: add, basicNum: basicNum&#125;// 引用自定义的模块时，参数包含路径，可省略.jsvar math = require(&apos;./math&apos;);math.add(2, 5);// 引用核心模块时，不需要带路径var http = require(&apos;http&apos;);http.createService(...).listen(3000); commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。 三、AMD和require.jsAMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。这里创建一个目录，目录下有这些文件： index.html require.js main.js eat.js num.js 最重要的是引入require.js文件和一个入口文件main.js。1.首先我们需要引入Index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模块化规范&lt;/title&gt; &lt;!-- AMD模块规范 requireJS--&gt; &lt;!-- 指定一个main文件--&gt; &lt;!-- 解决多js文件引入先后执行顺序问题--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;require.js&quot; data-main=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2.将require.js下载到本地3.eat.js num.js123456789//eat.jsdefine(function() &#123; function eat() &#123; alert(&quot;我正在吃饭&quot;); &#125; return &#123; eat: eat &#125;&#125;) 123456789101112define(function() &#123; function add(a,c) &#123; return a + c; &#125; function sub(a,c) &#123; return a - c; &#125; return &#123; add: add, sub: sub &#125;&#125;) 4.main.js12345require([&quot;./num.js&quot;,&quot;./eat.js&quot;],function(num_operator,eat_module) &#123; alert(num_operator.add(1,2)); alert(num_operator.sub(2,1)); eat_module.eat();&#125;); require([文件名，，，]，function(“模块1”,”模块2”,….)); 四、CMD和sea.jsrequire.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：123456789require([&quot;./num.js&quot;,&quot;./eat.js&quot;],function(num_operator,eat_module) &#123; // 等于在最前面声明并初始化了要用到的所有模块 if(false)&#123; // 即便没用到某个模块 eat_module，但 eat_module还是提前执行了 eat_module.eat(); &#125; alert(num_operator.add(1,2)); alert(num_operator.sub(2,1));&#125;); CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。这里创建一个目录，目录下有这些文件： index.html sea.js main.js num.js 最重要的是引入sea.js文件和一个入口文件main.js。1.首先我们需要引入Index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CMD规范 seajs&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;sea.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; seajs.use(&quot;main.js&quot;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.将sea.js下载到本地3.num.js123456define(function(require,exports,module) &#123; function add(a,c) &#123; return a + c; &#125; exports.add = add;&#125;) 4.main.js1234567891011121314let num = 10;console.log(10);//sea cmd模块define(function(require,exports,module) &#123; //同步 // let obj = require(&quot;num.js&quot;); // alert(obj.add(1,2)); //异步 require.async(&quot;./num.js&quot;,function() &#123; console.log(&quot;异步操作&quot;); &#125;)&#125;) 四、ES6 ModuleES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 123456789101112/** 定义模块 math.js **/var basicNum = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; basicNum, add &#125;;/** 引用模块 **/import &#123; basicNum, add &#125; from &apos;./math&apos;;function test(ele) &#123; ele.textContent = add(99 + basicNum);&#125; 1234567891011121314151617//a.jsexport let sum = ((x,y) =&gt; &#123; return x + y;&#125;);export let minus= ((x,y) =&gt; &#123; return x - y;&#125;);//b.js//第一种引用方法：import &#123;sum,minus&#125; from &apos;./a.js&apos;;console.log(`sum:$&#123;sum(1,3)&#125;`); //4console.log(`minus:$&#123;minus(10,2)&#125;`) //8//第二种引用方法：import * as util from &apos;./a.js&apos;;console.log(`util.sum:$&#123;util.sum(1,3)&#125;`); //4console.log(`util.minus:$&#123;util.minus(1,3)&#125;`); //8 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于AMD的引用写法。12345678/** export default **///定义输出export default &#123; basicNum, add &#125;;//引入import math from &apos;./math&apos;;function test(ele) &#123; ele.textContent = math.add(99 + math.basicNum);&#125; ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。 五、 ES6 模块与 CommonJS 模块的差异1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 本篇文章是结合网上一部分文章和自己的理解所写的。参考文章具体如下：http://es6.ruanyifeng.com/#docs/module-loaderhttps://blog.csdn.net/weixin_40811829/article/details/85311128https://juejin.im/post/5aaa37c8f265da23945f365c]]></content>
      <categories>
        <category>前端模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>CommonJS</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目下，用命令直接修复ESLint报错]]></title>
    <url>%2F2018%2F12%2F08%2Fvue%E9%A1%B9%E7%9B%AE%E4%B8%8B%EF%BC%8C%E7%94%A8%E5%91%BD%E4%BB%A4%E7%9B%B4%E6%8E%A5%E4%BF%AE%E5%A4%8DESLint%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本篇文章可适用于vue项目的eslint解决方案。 在写mpvue（小程序框架，其实也算是vue项目）项目过程引入ESLint代码规范，出现很多规范问题。 首先在项目的根目录下找到package.json文件，找到下面的位置，也就是“lint”这一条指令，指令后面具体内容不用深究。 然后修改成： 接下来，运行npm run lint 可以自动解决绝大多数错误，应该有可能包含一些错误只能手动解决的。 例如，我运行后，还剩下一个错误： 这个就只能根据错误文件定位去做相应的修改了，把==改成===。 当然，如果你坚决不改呢，那就在包含错误的那个文件头部加上1/*eslint-disable*/ 原理就是eslint不对该文件进行检查。 最后，个人对eslint代码规范的建议： 先把eslint关掉，最后项目开发完成再进行规范代码。 先找到根目录下的build文件夹的webpack.base.conf.js 找到这个位置，把代码注释掉 最后，项目开发完成后，再去掉注释，并按照前面的解决方法进行规范代码。]]></content>
      <categories>
        <category>ESlint</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax跨域请求以及传递cookie]]></title>
    <url>%2F2018%2F12%2F08%2Fajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E4%BC%A0%E9%80%92cookie%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文分为四大模块，第一模块是对跨域的介绍，第二模块是跨域解决方案，第三模块是ajax跨域传递cookie，第四模块是vue配置跨域。 一.跨域访问什么是跨域？ 这是因为浏览器的同源策略会导致跨域，只要协议，域名，端口有任何一个不同，都被当作是不同的域，之间的请求便为跨域操作。跨域访问一般是被阻止的，因为在安全上有个规则：同源策略要求客户端和服务端都必须在一个域内才能通信。比如网站A为a.test.com，网站B为b.test.com。按照上面所说，这两个网站属于不同域。所谓同源也就是网站A和网站B必须是相同的域名。 二.跨域解决方案1.jsonp实现跨域基于JSONP的实现原理,所以JSONP只能是GET请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了(所以如今它也基本被淘汰了) (1)type改成了get，JSONP只支持get请求，这个参数在JSONP场景下其实是可以忽略的，即使改成post，也会依然按get模式； (2)dataType改成了jsonp，这个参数标明要采用JSONP方式进行调用； (3)jsonp: “x5callback”，这个参数其实是一个约定的参数名，用于后端按照这个参数名获取一个回调函数名； (4)jsonpCallback：这个参数用来指定上面那个参数对应的回调函数名，如果不指定，jQuery会自动生成一个随机的函数名。 2.CORS（Cross-Origin Resource Sharing）方案这个方案是比较简单的，只需要在服务端返回的头部信息中增加：（下面分别给出PHP和node服务端的配置） 12345PHP//指定允许所有域名访问header('Access-Control-Allow-Origin:*');//指定允许指定域名访问header('Access-Control-Allow-Origin:http://www.xxx.com'); 12345678910Node//在相应添加这两条配置res.header('Access-Control-Allow-Origin', '*');app.all('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Access-Control-Allow-Methods', 'POST,GET'); res.header('Content-Type', 'application/json;charset=utf-8'); next();&#125;); 3.代理请求方式这里我也不是很熟悉，有兴趣的朋友上网自学。 三.ajax跨域传递cookie1.（客户端）前端ajax请求设置如下：1234567891011 $.ajax(&#123; url:_url, type:"post", data:"", dataType:"json", //实现跨域请求cookie xhrFields: &#123; withCredentials: true &#125;, crossDomain: true,&#125; 2.（服务端）后端设置如下： (PHP和Node为例）123456789101112PHP例子 //允许跨域传递cookieheader('Access-Control-Allow-Credentials:true');//这里需要注意必须设置为指定访问的域名header('Access-Control-Allow-Origin:http://www.xxx.com');//如果设置为所有域名都可访问，则会报错header('Access-Control-Allow-Origin:*');//最终配置header('Access-Control-Allow-Origin:http://www.xxx.com');header('Access-Control-Allow-Credentials:true'); 12345678910111213141516171819Node例子//允许跨域传递cookieres.header('Access-Control-Allow-Credentials', true);//这里需要注意必须设置为指定访问的域名res.header('Access-Control-Allow-Origin', 'http://www.xxx.com');//如果设置为所有域名都可访问，则会报错 res.header('Access-Control-Allow-Origin', '*');//最终配置app.all('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', 'http://www.xxx.com'); //Access-Control-Allow-Headers ,可根据浏览器的F12查看,把对应的粘贴在这里就行 res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Access-Control-Allow-Methods', 'POST,GET'); res.header('Access-Control-Allow-Credentials', true); res.header('Content-Type', 'application/json;charset=utf-8'); next();&#125;); 对应客户端的 xhrFields.withCredentials: true 参数，服务器端通过在响应 header 中设置 Access-Control-Allow-Credentials = true 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie。这里需要注意的是： 服务器端 Access-Control-Allow-Credentials = true时，参数Access-Control-Allow-Origin 的值不能为 * 。 这里顺便说一下cookie作用域问题。 domain表示的是cookie所在的域，默认为请求的地址如网址为www.jb51.net/test/test.aspx 那么domain默认为www.jb51.net。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。设置是放在ajax请求的位置，加上：123//这里t1.test.com能够访问t2.test.com，进行cookie传递。//t1.test.com不能访问t2.lin.comdocuemnt.cookie = 'domain=test.com'; 主机名是指同一个域下的不同主机，例如：www.google.com 和 gmail.google.com 就是两个不同的主机名。默认情况下，一个主机中创建的cookie在另一个主机下是不能被访问的，但可以通过domain参数来实现对其的控制，其语法格式为：1document.cookie="name=value; domain=cookieDomain"; 以google为例，要实现跨主机访问，可以写为：1document.cookie="name=value;domain=.google.com"; 这样，所有google.com下的主机都可以访问该cookie。 四.vue项目配置跨域在vue项目根目录下config/index.js1234567891011//找到dev配置项，直接添加dev: &#123; proxyTable: &#123; '/user': &#123; target: 'http://localhost:3000/', changeOrigin: true, pathRewrite: &#123; "^/user": '/user' &#125; &#125; &#125; 项目启动端口是8080,请求域名本来是：http://localhost:8080/user，会重定向为http://localhost:3000/userpathRewrite配置项的作用是，将一切/user/xxx等任何请求重定向，同时前端请求地址不用加上主机名，直接/user/xxx就可以。 本篇文章参考文章地址： 关于cookie: https://www.cnblogs.com/Jackie-sky/p/3672544.html cookie跨域：https://blog.csdn.net/qq_21956483/article/details/78720252]]></content>
      <categories>
        <category>ajax跨域请求cookie</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ajax</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网vuejs开发饿了么APP的知识总结]]></title>
    <url>%2F2018%2F12%2F08%2F%E6%85%95%E8%AF%BE%E7%BD%91vuejs%E5%BC%80%E5%8F%91%E9%A5%BF%E4%BA%86%E4%B9%88APP%E7%9A%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文分为两大模块，第一模块是项目总结，第二模块是知识点归纳。 一.项目总结1.项目源码与浏览项目源代码地址：https://github.com/suhuashan/elm-vue 2.项目打包(npm run build)1.将打包生成的dist文件放在本地或者是服务器，都会出现页面404，访问不到资源的问题，因为是路径问题。 需要修改config下面的index.js这个配置文件里选项assetsPubilcPath: ‘/‘改成‘./’。 再进行打包npm run build，然后再以服务器的形式来访问dist文件的index.html，便能访问。 我在项目根目录写了一个prod.sercer.js文件，然后运行node prod.server.js 这时候项目跑动起来了，访问localhost:9000. 2.因为我是在本地mock数据来模拟后台返回数据，在本地利用express来运行打包后的项目（dist文件夹）还是能够成功返回数据。但是当我把打包后的项目（dist文件夹）上传服务器后，发现数据无法返回。然后上网查了一下，发现自己写的api/seller等接口，是自己为了模拟后台数据而在自己本地写的接口，打包的时候是不会打包上去的，那个是服务端提供的接口，得在服务端写一个同样的接口才行。 然后我为了简便，于是在https://www.easy-mock.com/上面mock数据，就是简单把项目根目录的mockData.json内容写成3个线上接口，分别是： 返回商品数据的接口：https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/goods 返回商家数据的接口：https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/seller 返回评价数据的接口：https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/ratings 将自己项目的里面app.vue，goods.vue，ratings.vue文件里面的请求相应修改（这里举一例，其他类同），将下面本地的请求改成服务器的请求。 1234本地this.$axios.get('/api/goods')服务器this.$axios.get('https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/goods') 然后打包后的项目也能够成功在服务器跑起来了。 二.知识点总结下面是对于视频里面出现的几个亮点进行总结： 1.实现移动端细线的效果（如果在移动端直接设置1px的粗线，效果很不美观）(1)方案一（视频里面的方法）： 123456789101112//用media属性在不同手机像素比下显示不同的样式。@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) .border-1px &amp;::after -webkit-transform: scaleY(0.7) transform: scaleY(0.7) @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) .border-1px &amp;::after -webkit-transform: scaleY(0.5) transform: scaleY(0.5) 12345678910111213141516171819202122//项目里面多处用到1px下划线，所以进行抽离为公共的方法border-1px($color) position: relative &amp;:after display: block position: absolute left: 0 bottom: 0 width: 100% border-top: 1px solid $color content: ' '//如果仅仅某处使用到而已.class position: relative &amp;:after display: block position: absolute left: 0 bottom: 0 width: 100% border-top: 1px solid $color content: ' ' （2）方案二（曾经在网上看到的解决方案）： 2.Sticky footer布局实现这个网上已经很多很好的方案了，所以直接上链接 https://www.cnblogs.com/zsqos/archive/2017/06/02/6935646.html 3.移动端滚动better-scrollhttp://www.imooc.com/article/18232 https://github.com/ustbhuangyi/better-scroll 简单来说：当内容的宽度或者高度超过容器的宽高时，这时候就会产生滚动。但是better-scroll初始化一定要在页面DOM渲染完成后才开始计算内容的宽高，否则当内容的宽高大于容器时，无法滚动页面。 解决方案见上面第一个链接。]]></content>
      <categories>
        <category>Vue项目总结</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>慕课网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用指令详细说明]]></title>
    <url>%2F2018%2F12%2F07%2FGit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文主要讲解git一些常用且实用的操作，方便进行github托管代码。 Git常用命令1.git init1git init //初始当前目录，生成.git文件夹 2.git status1git status //查看当前本地分支下有没有文件被修改或者有没有新增文件 3.git clone123git clone &lt;版本库的网址&gt; git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; // 指定本地目录名git clone -o romoteBranchName &lt;版本库的网址&gt; //指定远程分支名称 clone 命令会创建指定本地目录名的文件夹把版本库的内容更新下来，默认创建本地分支 master 和远程分支 origin /master (这里的origin指的是远程主机名）并绑定；-o 可以指定远程分支名称；不指定本地目录名则创建与版本库目录名一样的目录。 4.git remote123456git remote //命令列出所有远程主机git remote -v //列出所有远程主机并展示远程主机的网址git remote show &lt;主机名&gt; //查看远程分支的详细状况git remote add &lt;主机名&gt; &lt;网址&gt; //添加远程主机名git remote rm &lt;主机名&gt; // 删除远程主机git remote rename &lt;原主机名&gt; &lt;新主机名&gt; // 修改远程主机名 默认远程主机名：origin 5.git branch123git branch //查看本地分支 现在所在的分支会有 * 号标注git branch -r //查看远程分支git branch -a //查看所有分支（本地+远程） 6.git checkout123git checkout 分支名 //切换到指定分支//指定本地分支切出新分支并切换。不指定分支时根据当前分支切新分支git checkout -b newBrach 生成本地新分支 本地和远程默认分支都是master 7.git merge123git checkout 分支名 //切换到指定分支//指定本地分支切出新分支并切换。不指定分支时根据当前分支切新分支git checkout -b newBrach 生成本地新分支 注意:git fetch后当前目录没有任何改变，需要git merge才会得到 可以近似认为：git fetch + git merge = git pull 8.git pull1234//把指定远程主机名远程分支的内容拉取到指定的本地分支git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;//把指定分支内容拉取到当前本地分支，相当于先 fetch 再 mergegit pull &lt;远程主机名&gt; &lt;远程分支名&gt; 注意：默认远程主机名：origin 如果需要自己添加远程主机名，请执行git remote命令 9.git push12345678//把指定本地分支的 commit 推到指定的远程主机远程分支上git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;//把本地分支推送与之存在"追踪关系"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。git push &lt;远程主机名&gt; &lt;远程分支名&gt; //删除指定的远程分支，等同于推送一个空的本地分支到远程分支git push &lt;远程主机名&gt;:&lt;远程分支名&gt;//指定默认主机，下次直接 git push 即可git push -u &lt;远程主机名&gt; &lt;本地分支名&gt; 如果执行git push相关命令后出现下面提示，意味着文件没改变。 参考文章地址： https://git-scm.com/book/zh/v1 http://www.ruanyifeng.com/blog/2014/06/git_remote.html https://blog.csdn.net/weixin_40811829/article/details/84798530]]></content>
      <categories>
        <category>git常用操作</category>
      </categories>
      <tags>
        <tag>git指令</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建博客最全配置]]></title>
    <url>%2F2018%2F09%2F21%2Fhexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%9C%80%E5%85%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文分为两大模块，第一模块是搭建博客，第二模块是博客主题进行配置，当然我选用的主题是Next。 一.博客搭建1.搭建 Node.js 环境为什么要搭建Node.js环境？ - 因为Hexo博客系统是基于Node.js编写的。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。 在Node.js官网：https://nodejs.org/en/ 下载安装包，推荐下载官方推荐(Recommonded)的版本。 保持默认设置即可，一路Next，安装很快就结束了。 windows打开命令提示符，输入node -v、npm -v出现版本号则说明Node.js环境配置成功，第一步完成！！！ 2.搭建 Git 环境为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上。 Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 在 Git 官网：https://git-scm.com/ 下载安装包，对准自己电脑的操作系统下载一个就可以了 桌面右键，打开 Git Bush Here，输入 git –version，出现版本号则说明 Git 环境配置成功，第二步完成！！！ 3.GitHub 注册和配置GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。 Github注册：https://github.com/ 注册或者登陆好之后就开始创建仓库。 创建仓库：Repository name 使用自己的用户名。注意：yourname 必须是你的用户名。1yourname/yourname.github.io 访问 yourname.github.io，如果可以正常访问，那么 Github 的配置已经结束了。 到此搭建 Hexo 博客的相关环境配置已经完成，下面开始讲解 Hexo 的相关操作。 4.安装配置 HexoHexo 是一个快速、简洁且高效的博客框架，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 官方文档：https://hexo.io/zh-cn/ 使用 npm 安装 Hexo：在命令行中输入1npm install hexo-cli -g 注意：博主在安装这个包出现管理员权限问题，无法成功安装。于是按 win + x 打开 Window PowerShell,重新安装就可以了，如果安装过程出现WARN，不用担心，因为不会影响正常使用。 查看 Hexo 的版本1hexo version Hexo 安装成功后，在本地创建一个文件夹，文件夹名随意（我命名为blog)，然后鼠标右击该文件夹，按顺序执行下面的命令。123hexo initnpm install 新建完成后，指定文件夹的目录如下：1234567891011.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json #npm 依赖等 运行本地 Hexo 服务123hexo server或者hexo s 您的网站会在 http://localhost:4000 下启动。如果 http://localhost:4000 能够正常访问，则说明 Hexo 本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。 注意1：执行hexo server提示找不到该指令 解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：123sudo npm install hexo-server或者npm install hexo -server --save 5.关联 Hexo 与 GitHub Pages在前面创建的文件夹里面鼠标右键，点击1Git Base Here 将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）12git -config --global user.name "your github name"git -config --global user.email "your email" 接着输入1ssh-keygen -t rsa -C "your email" 连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh或者C:\Users\具体用户.ssh）。 登录 Github，点击头像下的 settings，添加 ssh点击 SSH and GPG keys新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 配置 Deployment 在文件夹的根目录找到_config.yml文件，打开该文件找到Deployment，然后按照如下修改，用户名改成你的信息(需要注意的是：冒号后面记得空一格！)123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:yourname(github的用户名)/yourname.github.io.git branch: master 本地文件提交到 GitHub Pages123456789101112// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo d 在浏览器中输入 https://yourname(github的用户名).github.io，你会发现和在本地看到一模一样。 这样，本地 git 项目与远程的 github 建立联系。 6.发表新文章1hexo new "文章标题" //在本地文件夹根目录下输入该命令 在本地博客文件夹 source_posts 文件夹下看到我们新建的 markdown 文件。 当然，我们也可以手动添加Markdown文件在source/post文件夹下，其效果同样可以媲美hexo new指令 文章编辑好之后，运行生成、部署命令： 12345hexo cleanhexo ghexo d 参考链接：https://oakland.github.io/2016/05/02/hexo-%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84post/ 7.GitHub Pages 地址解析到个人域名在 GitHub 仓库的根目录下建立一个 CNAME 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加http://1blog.suhuashan.xin 注意：CNAME 一定是在你 Github 项目的 master 根目录下 进入阿里云域名解析地址，添加解析：12345678910记录类型选择CNAME主机记录填blog //当然填写www也可以，自拟一个吧解析线路选择默认记录值填yourname.github.ioTTL值为10分钟再添加一个解析，记录类型A主机记录填www解析线路选择默认记录值填你GitHub 的ip地址（在cmd中ping：）ping suhuashan.github.io 保存，等待一下访问suhuashan.github.io，域名会重定向为blog.suhuashan.xin 注意：CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐 方法一：每次 hexo d 之后，就去 GitHub 仓库根目录新建 CNAME文件 方法二：在 hexo g 之后， hexo d 之前，把CNAME文件复制到 “\public\” 目录下面，里面写入你要绑定的域名。 方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。 二.Hexo的Next主题详细配置这一块我就不多说了，毕竟网上已经有很完美的教程。但是我会提出教程几个讲的比较模糊的地方，然后对不清晰的地方重新配置。 Next 官方文档：http://theme-next.iissnan.com/教程参考(我对网上大部分进行筛选，个人觉得以下这两个比较管用)：https://www.jianshu.com/p/3a05351a37dchttps://zhuanlan.zhihu.com/p/28128674 教程里面需要修改的地方： 1.添加分类模块新建一个分类页面1hexo new page categories 这时候，source文件夹下有了categorcies/index.md，最关键就是要设置type123title: 分类date: 2018-09-20 23:27:47 //按照自己的时间就可以了type: "categories" 打开 主题配置文件 找到menu，将categorcies取消注释 以后写博客直接在文章的 title 下面加上 categorcies 就可以了，例如：123title: 分类测试文章标题categorcies: 测试 //一个类别的情况categorcies: [测试, 验证] //多个类别的情况写成数组 2.添加标签模块新建一个标签页面1hexo new page tags 这时候，source文件夹下有了tags/index.md，最关键就是要设置type123title: 分类date: 2018-09-20 23:27:47 //按照自己的时间就可以了type: "tags" 打开 主题配置文件 找到menu，将tags取消注释 以后写博客直接在文章的 title 下面加上 tags 就可以了，例如：123title: 标签测试文章标题tags: 测试 //一个类别的情况tags: [测试, 验证] //多个类别的情况写成数组 其他配置就按照教程就可以了！]]></content>
      <categories>
        <category>博客搭建教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
