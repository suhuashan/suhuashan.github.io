<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端模块化：CommonJS,AMD,CMD,ES6]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9ACommonJS-AMD-CMD-ES6%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文主要讲解前端模块化，其中包括CommonJS,AMD,CMD,ES6模块化。 一、模块化开发为什么要模块化开发呢？其一，解决模块中函数名重复的问题；其二，解决模块之间的依赖关系。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。具体可以参考阮一峰老师的文章：module-loader 二、CommonJSNode.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块。 1234567891011121314151617// 定义模块math.jsvar basicNum = 0;function add(a, b) &#123; return a + b;&#125;module.exports = &#123; //在这里写上需要向外暴露的函数、变量 add: add, basicNum: basicNum&#125;// 引用自定义的模块时，参数包含路径，可省略.jsvar math = require(&apos;./math&apos;);math.add(2, 5);// 引用核心模块时，不需要带路径var http = require(&apos;http&apos;);http.createService(...).listen(3000); commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。 三、AMD和require.jsAMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块。这里创建一个目录，目录下有这些文件： index.html require.js main.js eat.js num.js 最重要的是引入require.js文件和一个入口文件main.js。1.首先我们需要引入Index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;模块化规范&lt;/title&gt; &lt;!-- AMD模块规范 requireJS--&gt; &lt;!-- 指定一个main文件--&gt; &lt;!-- 解决多js文件引入先后执行顺序问题--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;require.js&quot; data-main=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; 2.将require.js下载到本地3.eat.js num.js123456789//eat.jsdefine(function() &#123; function eat() &#123; alert(&quot;我正在吃饭&quot;); &#125; return &#123; eat: eat &#125;&#125;) 123456789101112define(function() &#123; function add(a,c) &#123; return a + c; &#125; function sub(a,c) &#123; return a - c; &#125; return &#123; add: add, sub: sub &#125;&#125;) 4.main.js12345require([&quot;./num.js&quot;,&quot;./eat.js&quot;],function(num_operator,eat_module) &#123; alert(num_operator.add(1,2)); alert(num_operator.sub(2,1)); eat_module.eat();&#125;); require([文件名，，，]，function(“模块1”,”模块2”,….)); 四、CMD和sea.jsrequire.js在申明依赖的模块时会在第一之间加载并执行模块内的代码：123456789require([&quot;./num.js&quot;,&quot;./eat.js&quot;],function(num_operator,eat_module) &#123; // 等于在最前面声明并初始化了要用到的所有模块 if(false)&#123; // 即便没用到某个模块 eat_module，但 eat_module还是提前执行了 eat_module.eat(); &#125; alert(num_operator.add(1,2)); alert(num_operator.sub(2,1));&#125;); CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。这里创建一个目录，目录下有这些文件： index.html sea.js main.js num.js 最重要的是引入sea.js文件和一个入口文件main.js。1.首先我们需要引入Index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CMD规范 seajs&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;sea.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; seajs.use(&quot;main.js&quot;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.将sea.js下载到本地3.num.js123456define(function(require,exports,module) &#123; function add(a,c) &#123; return a + c; &#125; exports.add = add;&#125;) 4.main.js1234567891011121314let num = 10;console.log(10);//sea cmd模块define(function(require,exports,module) &#123; //同步 // let obj = require(&quot;num.js&quot;); // alert(obj.add(1,2)); //异步 require.async(&quot;./num.js&quot;,function() &#123; console.log(&quot;异步操作&quot;); &#125;)&#125;) 四、ES6 ModuleES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 123456789101112/** 定义模块 math.js **/var basicNum = 0;var add = function (a, b) &#123; return a + b;&#125;;export &#123; basicNum, add &#125;;/** 引用模块 **/import &#123; basicNum, add &#125; from &apos;./math&apos;;function test(ele) &#123; ele.textContent = add(99 + basicNum);&#125; 1234567891011121314151617//a.jsexport let sum = ((x,y) =&gt; &#123; return x + y;&#125;);export let minus= ((x,y) =&gt; &#123; return x - y;&#125;);//b.js//第一种引用方法：import &#123;sum,minus&#125; from &apos;./a.js&apos;;console.log(`sum:$&#123;sum(1,3)&#125;`); //4console.log(`minus:$&#123;minus(10,2)&#125;`) //8//第二种引用方法：import * as util from &apos;./a.js&apos;;console.log(`util.sum:$&#123;util.sum(1,3)&#125;`); //4console.log(`util.minus:$&#123;util.minus(1,3)&#125;`); //8 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于AMD的引用写法。12345678/** export default **///定义输出export default &#123; basicNum, add &#125;;//引入import math from &apos;./math&apos;;function test(ele) &#123; ele.textContent = math.add(99 + math.basicNum);&#125; ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。 五、 ES6 模块与 CommonJS 模块的差异1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 本篇文章是结合网上一部分文章和自己的理解所写的。参考文章具体如下：http://es6.ruanyifeng.com/#docs/module-loaderhttps://blog.csdn.net/weixin_40811829/article/details/85311128https://juejin.im/post/5aaa37c8f265da23945f365c]]></content>
      <categories>
        <category>前端模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>CommonJS</tag>
        <tag>AMD</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目下，用命令直接修复ESLint报错]]></title>
    <url>%2F2018%2F12%2F08%2Fvue%E9%A1%B9%E7%9B%AE%E4%B8%8B%EF%BC%8C%E7%94%A8%E5%91%BD%E4%BB%A4%E7%9B%B4%E6%8E%A5%E4%BF%AE%E5%A4%8DESLint%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本篇文章可适用于vue项目的eslint解决方案。 在写mpvue（小程序框架，其实也算是vue项目）项目过程引入ESLint代码规范，出现很多规范问题。 首先在项目的根目录下找到package.json文件，找到下面的位置，也就是“lint”这一条指令，指令后面具体内容不用深究。 然后修改成： 接下来，运行npm run lint 可以自动解决绝大多数错误，应该有可能包含一些错误只能手动解决的。 例如，我运行后，还剩下一个错误： 这个就只能根据错误文件定位去做相应的修改了，把==改成===。 当然，如果你坚决不改呢，那就在包含错误的那个文件头部加上1/*eslint-disable*/ 原理就是eslint不对该文件进行检查。 最后，个人对eslint代码规范的建议： 先把eslint关掉，最后项目开发完成再进行规范代码。 先找到根目录下的build文件夹的webpack.base.conf.js 找到这个位置，把代码注释掉 最后，项目开发完成后，再去掉注释，并按照前面的解决方法进行规范代码。]]></content>
      <categories>
        <category>ESlint</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax跨域请求以及传递cookie]]></title>
    <url>%2F2018%2F12%2F08%2Fajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E4%BC%A0%E9%80%92cookie%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文分为四大模块，第一模块是对跨域的介绍，第二模块是跨域解决方案，第三模块是ajax跨域传递cookie，第四模块是vue配置跨域。 一.跨域访问什么是跨域？ 这是因为浏览器的同源策略会导致跨域，只要协议，域名，端口有任何一个不同，都被当作是不同的域，之间的请求便为跨域操作。跨域访问一般是被阻止的，因为在安全上有个规则：同源策略要求客户端和服务端都必须在一个域内才能通信。比如网站A为a.test.com，网站B为b.test.com。按照上面所说，这两个网站属于不同域。所谓同源也就是网站A和网站B必须是相同的域名。 二.跨域解决方案1.jsonp实现跨域基于JSONP的实现原理,所以JSONP只能是GET请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了(所以如今它也基本被淘汰了) (1)type改成了get，JSONP只支持get请求，这个参数在JSONP场景下其实是可以忽略的，即使改成post，也会依然按get模式； (2)dataType改成了jsonp，这个参数标明要采用JSONP方式进行调用； (3)jsonp: “x5callback”，这个参数其实是一个约定的参数名，用于后端按照这个参数名获取一个回调函数名； (4)jsonpCallback：这个参数用来指定上面那个参数对应的回调函数名，如果不指定，jQuery会自动生成一个随机的函数名。 2.CORS（Cross-Origin Resource Sharing）方案这个方案是比较简单的，只需要在服务端返回的头部信息中增加：（下面分别给出PHP和node服务端的配置） 12345PHP//指定允许所有域名访问header('Access-Control-Allow-Origin:*');//指定允许指定域名访问header('Access-Control-Allow-Origin:http://www.xxx.com'); 12345678910Node//在相应添加这两条配置res.header('Access-Control-Allow-Origin', '*');app.all('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Access-Control-Allow-Methods', 'POST,GET'); res.header('Content-Type', 'application/json;charset=utf-8'); next();&#125;); 3.代理请求方式这里我也不是很熟悉，有兴趣的朋友上网自学。 三.ajax跨域传递cookie1.（客户端）前端ajax请求设置如下：1234567891011 $.ajax(&#123; url:_url, type:"post", data:"", dataType:"json", //实现跨域请求cookie xhrFields: &#123; withCredentials: true &#125;, crossDomain: true,&#125; 2.（服务端）后端设置如下： (PHP和Node为例）123456789101112PHP例子 //允许跨域传递cookieheader('Access-Control-Allow-Credentials:true');//这里需要注意必须设置为指定访问的域名header('Access-Control-Allow-Origin:http://www.xxx.com');//如果设置为所有域名都可访问，则会报错header('Access-Control-Allow-Origin:*');//最终配置header('Access-Control-Allow-Origin:http://www.xxx.com');header('Access-Control-Allow-Credentials:true'); 12345678910111213141516171819Node例子//允许跨域传递cookieres.header('Access-Control-Allow-Credentials', true);//这里需要注意必须设置为指定访问的域名res.header('Access-Control-Allow-Origin', 'http://www.xxx.com');//如果设置为所有域名都可访问，则会报错 res.header('Access-Control-Allow-Origin', '*');//最终配置app.all('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', 'http://www.xxx.com'); //Access-Control-Allow-Headers ,可根据浏览器的F12查看,把对应的粘贴在这里就行 res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Access-Control-Allow-Methods', 'POST,GET'); res.header('Access-Control-Allow-Credentials', true); res.header('Content-Type', 'application/json;charset=utf-8'); next();&#125;); 对应客户端的 xhrFields.withCredentials: true 参数，服务器端通过在响应 header 中设置 Access-Control-Allow-Credentials = true 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie。这里需要注意的是： 服务器端 Access-Control-Allow-Credentials = true时，参数Access-Control-Allow-Origin 的值不能为 * 。 这里顺便说一下cookie作用域问题。 domain表示的是cookie所在的域，默认为请求的地址如网址为www.jb51.net/test/test.aspx 那么domain默认为www.jb51.net。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。设置是放在ajax请求的位置，加上：123//这里t1.test.com能够访问t2.test.com，进行cookie传递。//t1.test.com不能访问t2.lin.comdocuemnt.cookie = 'domain=test.com'; 主机名是指同一个域下的不同主机，例如：www.google.com 和 gmail.google.com 就是两个不同的主机名。默认情况下，一个主机中创建的cookie在另一个主机下是不能被访问的，但可以通过domain参数来实现对其的控制，其语法格式为：1document.cookie="name=value; domain=cookieDomain"; 以google为例，要实现跨主机访问，可以写为：1document.cookie="name=value;domain=.google.com"; 这样，所有google.com下的主机都可以访问该cookie。 四.vue项目配置跨域在vue项目根目录下config/index.js1234567891011//找到dev配置项，直接添加dev: &#123; proxyTable: &#123; '/user': &#123; target: 'http://localhost:3000/', changeOrigin: true, pathRewrite: &#123; "^/user": '/user' &#125; &#125; &#125; 项目启动端口是8080,请求域名本来是：http://localhost:8080/user，会重定向为http://localhost:3000/userpathRewrite配置项的作用是，将一切/user/xxx等任何请求重定向，同时前端请求地址不用加上主机名，直接/user/xxx就可以。 本篇文章参考文章地址： 关于cookie: https://www.cnblogs.com/Jackie-sky/p/3672544.html cookie跨域：https://blog.csdn.net/qq_21956483/article/details/78720252]]></content>
      <categories>
        <category>ajax跨域请求cookie</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ajax</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网vuejs开发饿了么APP的知识总结]]></title>
    <url>%2F2018%2F12%2F08%2F%E6%85%95%E8%AF%BE%E7%BD%91vuejs%E5%BC%80%E5%8F%91%E9%A5%BF%E4%BA%86%E4%B9%88APP%E7%9A%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文分为两大模块，第一模块是项目总结，第二模块是知识点归纳。 一.项目总结1.项目源码与浏览项目源代码地址：https://github.com/suhuashan/elm-vue 2.项目打包(npm run build)1.将打包生成的dist文件放在本地或者是服务器，都会出现页面404，访问不到资源的问题，因为是路径问题。 需要修改config下面的index.js这个配置文件里选项assetsPubilcPath: ‘/‘改成‘./’。 再进行打包npm run build，然后再以服务器的形式来访问dist文件的index.html，便能访问。 我在项目根目录写了一个prod.sercer.js文件，然后运行node prod.server.js 这时候项目跑动起来了，访问localhost:9000. 2.因为我是在本地mock数据来模拟后台返回数据，在本地利用express来运行打包后的项目（dist文件夹）还是能够成功返回数据。但是当我把打包后的项目（dist文件夹）上传服务器后，发现数据无法返回。然后上网查了一下，发现自己写的api/seller等接口，是自己为了模拟后台数据而在自己本地写的接口，打包的时候是不会打包上去的，那个是服务端提供的接口，得在服务端写一个同样的接口才行。 然后我为了简便，于是在https://www.easy-mock.com/上面mock数据，就是简单把项目根目录的mockData.json内容写成3个线上接口，分别是： 返回商品数据的接口：https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/goods 返回商家数据的接口：https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/seller 返回评价数据的接口：https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/ratings 将自己项目的里面app.vue，goods.vue，ratings.vue文件里面的请求相应修改（这里举一例，其他类同），将下面本地的请求改成服务器的请求。 1234本地this.$axios.get('/api/goods')服务器this.$axios.get('https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/goods') 然后打包后的项目也能够成功在服务器跑起来了。 二.知识点总结下面是对于视频里面出现的几个亮点进行总结： 1.实现移动端细线的效果（如果在移动端直接设置1px的粗线，效果很不美观）(1)方案一（视频里面的方法）： 123456789101112//用media属性在不同手机像素比下显示不同的样式。@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) .border-1px &amp;::after -webkit-transform: scaleY(0.7) transform: scaleY(0.7) @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) .border-1px &amp;::after -webkit-transform: scaleY(0.5) transform: scaleY(0.5) 12345678910111213141516171819202122//项目里面多处用到1px下划线，所以进行抽离为公共的方法border-1px($color) position: relative &amp;:after display: block position: absolute left: 0 bottom: 0 width: 100% border-top: 1px solid $color content: ' '//如果仅仅某处使用到而已.class position: relative &amp;:after display: block position: absolute left: 0 bottom: 0 width: 100% border-top: 1px solid $color content: ' ' （2）方案二（曾经在网上看到的解决方案）： 2.Sticky footer布局实现这个网上已经很多很好的方案了，所以直接上链接 https://www.cnblogs.com/zsqos/archive/2017/06/02/6935646.html 3.移动端滚动better-scrollhttp://www.imooc.com/article/18232 https://github.com/ustbhuangyi/better-scroll 简单来说：当内容的宽度或者高度超过容器的宽高时，这时候就会产生滚动。但是better-scroll初始化一定要在页面DOM渲染完成后才开始计算内容的宽高，否则当内容的宽高大于容器时，无法滚动页面。 解决方案见上面第一个链接。]]></content>
      <categories>
        <category>Vue项目总结</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>慕课网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用指令详细说明]]></title>
    <url>%2F2018%2F12%2F07%2FGit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文主要讲解git一些常用且实用的操作，方便进行github托管代码。 Git常用命令1.git init1git init //初始当前目录，生成.git文件夹 2.git status1git status //查看当前本地分支下有没有文件被修改或者有没有新增文件 3.git clone123git clone &lt;版本库的网址&gt; git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; // 指定本地目录名git clone -o romoteBranchName &lt;版本库的网址&gt; //指定远程分支名称 clone 命令会创建指定本地目录名的文件夹把版本库的内容更新下来，默认创建本地分支 master 和远程分支 origin /master (这里的origin指的是远程主机名）并绑定；-o 可以指定远程分支名称；不指定本地目录名则创建与版本库目录名一样的目录。 4.git remote123456git remote //命令列出所有远程主机git remote -v //列出所有远程主机并展示远程主机的网址git remote show &lt;主机名&gt; //查看远程分支的详细状况git remote add &lt;主机名&gt; &lt;网址&gt; //添加远程主机名git remote rm &lt;主机名&gt; // 删除远程主机git remote rename &lt;原主机名&gt; &lt;新主机名&gt; // 修改远程主机名 默认远程主机名：origin 5.git branch123git branch //查看本地分支 现在所在的分支会有 * 号标注git branch -r //查看远程分支git branch -a //查看所有分支（本地+远程） 6.git checkout123git checkout 分支名 //切换到指定分支//指定本地分支切出新分支并切换。不指定分支时根据当前分支切新分支git checkout -b newBrach 生成本地新分支 本地和远程默认分支都是master 7.git merge123git checkout 分支名 //切换到指定分支//指定本地分支切出新分支并切换。不指定分支时根据当前分支切新分支git checkout -b newBrach 生成本地新分支 注意:git fetch后当前目录没有任何改变，需要git merge才会得到 可以近似认为：git fetch + git merge = git pull 8.git pull1234//把指定远程主机名远程分支的内容拉取到指定的本地分支git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;//把指定分支内容拉取到当前本地分支，相当于先 fetch 再 mergegit pull &lt;远程主机名&gt; &lt;远程分支名&gt; 注意：默认远程主机名：origin 如果需要自己添加远程主机名，请执行git remote命令 9.git push12345678//把指定本地分支的 commit 推到指定的远程主机远程分支上git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;//把本地分支推送与之存在"追踪关系"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。git push &lt;远程主机名&gt; &lt;远程分支名&gt; //删除指定的远程分支，等同于推送一个空的本地分支到远程分支git push &lt;远程主机名&gt;:&lt;远程分支名&gt;//指定默认主机，下次直接 git push 即可git push -u &lt;远程主机名&gt; &lt;本地分支名&gt; 如果执行git push相关命令后出现下面提示，意味着文件没改变。 参考文章地址： https://git-scm.com/book/zh/v1 http://www.ruanyifeng.com/blog/2014/06/git_remote.html https://blog.csdn.net/weixin_40811829/article/details/84798530]]></content>
      <categories>
        <category>git常用操作</category>
      </categories>
      <tags>
        <tag>git指令</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建博客最全配置]]></title>
    <url>%2F2018%2F09%2F21%2Fhexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%9C%80%E5%85%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[博主博客地址: https://blog.suhuashan.xin本文分为两大模块，第一模块是搭建博客，第二模块是博客主题进行配置，当然我选用的主题是Next。 一.博客搭建1.搭建 Node.js 环境为什么要搭建Node.js环境？ - 因为Hexo博客系统是基于Node.js编写的。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。 在Node.js官网：https://nodejs.org/en/ 下载安装包，推荐下载官方推荐(Recommonded)的版本。 保持默认设置即可，一路Next，安装很快就结束了。 windows打开命令提示符，输入node -v、npm -v出现版本号则说明Node.js环境配置成功，第一步完成！！！ 2.搭建 Git 环境为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上。 Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 在 Git 官网：https://git-scm.com/ 下载安装包，对准自己电脑的操作系统下载一个就可以了 桌面右键，打开 Git Bush Here，输入 git –version，出现版本号则说明 Git 环境配置成功，第二步完成！！！ 3.GitHub 注册和配置GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。 Github注册：https://github.com/ 注册或者登陆好之后就开始创建仓库。 创建仓库：Repository name 使用自己的用户名。注意：yourname 必须是你的用户名。1yourname/yourname.github.io 访问 yourname.github.io，如果可以正常访问，那么 Github 的配置已经结束了。 到此搭建 Hexo 博客的相关环境配置已经完成，下面开始讲解 Hexo 的相关操作。 4.安装配置 HexoHexo 是一个快速、简洁且高效的博客框架，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 官方文档：https://hexo.io/zh-cn/ 使用 npm 安装 Hexo：在命令行中输入1npm install hexo-cli -g 注意：博主在安装这个包出现管理员权限问题，无法成功安装。于是按 win + x 打开 Window PowerShell,重新安装就可以了，如果安装过程出现WARN，不用担心，因为不会影响正常使用。 查看 Hexo 的版本1hexo version Hexo 安装成功后，在本地创建一个文件夹，文件夹名随意（我命名为blog)，然后鼠标右击该文件夹，按顺序执行下面的命令。123hexo initnpm install 新建完成后，指定文件夹的目录如下：1234567891011.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json #npm 依赖等 运行本地 Hexo 服务123hexo server或者hexo s 您的网站会在 http://localhost:4000 下启动。如果 http://localhost:4000 能够正常访问，则说明 Hexo 本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。 注意1：执行hexo server提示找不到该指令 解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：123sudo npm install hexo-server或者npm install hexo -server --save 5.关联 Hexo 与 GitHub Pages在前面创建的文件夹里面鼠标右键，点击1Git Base Here 将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）12git -config --global user.name "your github name"git -config --global user.email "your email" 接着输入1ssh-keygen -t rsa -C "your email" 连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh或者C:\Users\具体用户.ssh）。 登录 Github，点击头像下的 settings，添加 ssh点击 SSH and GPG keys新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 配置 Deployment 在文件夹的根目录找到_config.yml文件，打开该文件找到Deployment，然后按照如下修改，用户名改成你的信息(需要注意的是：冒号后面记得空一格！)123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:yourname(github的用户名)/yourname.github.io.git branch: master 本地文件提交到 GitHub Pages123456789101112// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo d 在浏览器中输入 https://yourname(github的用户名).github.io，你会发现和在本地看到一模一样。 这样，本地 git 项目与远程的 github 建立联系。 6.发表新文章1hexo new "文章标题" //在本地文件夹根目录下输入该命令 在本地博客文件夹 source_posts 文件夹下看到我们新建的 markdown 文件。 当然，我们也可以手动添加Markdown文件在source/post文件夹下，其效果同样可以媲美hexo new指令 文章编辑好之后，运行生成、部署命令： 12345hexo cleanhexo ghexo d 参考链接：https://oakland.github.io/2016/05/02/hexo-%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84post/ 7.GitHub Pages 地址解析到个人域名在 GitHub 仓库的根目录下建立一个 CNAME 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加http://1blog.suhuashan.xin 注意：CNAME 一定是在你 Github 项目的 master 根目录下 进入阿里云域名解析地址，添加解析：12345678910记录类型选择CNAME主机记录填blog //当然填写www也可以，自拟一个吧解析线路选择默认记录值填yourname.github.ioTTL值为10分钟再添加一个解析，记录类型A主机记录填www解析线路选择默认记录值填你GitHub 的ip地址（在cmd中ping：）ping suhuashan.github.io 保存，等待一下访问suhuashan.github.io，域名会重定向为blog.suhuashan.xin 注意：CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐 方法一：每次 hexo d 之后，就去 GitHub 仓库根目录新建 CNAME文件 方法二：在 hexo g 之后， hexo d 之前，把CNAME文件复制到 “\public\” 目录下面，里面写入你要绑定的域名。 方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。 二.Hexo的Next主题详细配置这一块我就不多说了，毕竟网上已经有很完美的教程。但是我会提出教程几个讲的比较模糊的地方，然后对不清晰的地方重新配置。 Next 官方文档：http://theme-next.iissnan.com/教程参考(我对网上大部分进行筛选，个人觉得以下这两个比较管用)：https://www.jianshu.com/p/3a05351a37dchttps://zhuanlan.zhihu.com/p/28128674 教程里面需要修改的地方： 1.添加分类模块新建一个分类页面1hexo new page categories 这时候，source文件夹下有了categorcies/index.md，最关键就是要设置type123title: 分类date: 2018-09-20 23:27:47 //按照自己的时间就可以了type: "categories" 打开 主题配置文件 找到menu，将categorcies取消注释 以后写博客直接在文章的 title 下面加上 categorcies 就可以了，例如：123title: 分类测试文章标题categorcies: 测试 //一个类别的情况categorcies: [测试, 验证] //多个类别的情况写成数组 2.添加标签模块新建一个标签页面1hexo new page tags 这时候，source文件夹下有了tags/index.md，最关键就是要设置type123title: 分类date: 2018-09-20 23:27:47 //按照自己的时间就可以了type: "tags" 打开 主题配置文件 找到menu，将tags取消注释 以后写博客直接在文章的 title 下面加上 tags 就可以了，例如：123title: 标签测试文章标题tags: 测试 //一个类别的情况tags: [测试, 验证] //多个类别的情况写成数组 其他配置就按照教程就可以了！]]></content>
      <categories>
        <category>博客搭建教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
