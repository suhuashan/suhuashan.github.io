<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ajax跨域请求以及传递cookie]]></title>
    <url>%2F2018%2F12%2F08%2Fajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%BB%A5%E5%8F%8A%E4%BC%A0%E9%80%92cookie%2F</url>
    <content type="text"><![CDATA[博主博客地址: http://blog.suhuashan.xin本文分为四大模块，第一模块是对跨域的介绍，第二模块是跨域解决方案，第三模块是ajax跨域传递cookie，第四模块是vue配置跨域。 一.跨域访问什么是跨域？ 这是因为浏览器的同源策略会导致跨域，只要协议，域名，端口有任何一个不同，都被当作是不同的域，之间的请求便为跨域操作。跨域访问一般是被阻止的，因为在安全上有个规则：同源策略要求客户端和服务端都必须在一个域内才能通信。比如网站A为a.test.com，网站B为b.test.com。按照上面所说，这两个网站属于不同域。所谓同源也就是网站A和网站B必须是相同的域名。 二.跨域解决方案1.jsonp实现跨域基于JSONP的实现原理,所以JSONP只能是GET请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了(所以如今它也基本被淘汰了) (1)type改成了get，JSONP只支持get请求，这个参数在JSONP场景下其实是可以忽略的，即使改成post，也会依然按get模式； (2)dataType改成了jsonp，这个参数标明要采用JSONP方式进行调用； (3)jsonp: “x5callback”，这个参数其实是一个约定的参数名，用于后端按照这个参数名获取一个回调函数名； (4)jsonpCallback：这个参数用来指定上面那个参数对应的回调函数名，如果不指定，jQuery会自动生成一个随机的函数名。 2.CORS（Cross-Origin Resource Sharing）方案这个方案是比较简单的，只需要在服务端返回的头部信息中增加：（下面分别给出PHP和node服务端的配置） 12345PHP//指定允许所有域名访问header('Access-Control-Allow-Origin:*');//指定允许指定域名访问header('Access-Control-Allow-Origin:http://www.xxx.com'); 12345678910Node//在相应添加这两条配置res.header('Access-Control-Allow-Origin', '*');app.all('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Access-Control-Allow-Methods', 'POST,GET'); res.header('Content-Type', 'application/json;charset=utf-8'); next();&#125;); 3.代理请求方式这里我也不是很熟悉，有兴趣的朋友上网自学。 三.ajax跨域传递cookie1.（客户端）前端ajax请求设置如下：1234567891011 $.ajax(&#123; url:_url, type:"post", data:"", dataType:"json", //实现跨域请求cookie xhrFields: &#123; withCredentials: true &#125;, crossDomain: true,&#125; 2.（服务端）后端设置如下： (PHP和Node为例）123456789101112PHP例子 //允许跨域传递cookieheader('Access-Control-Allow-Credentials:true');//这里需要注意必须设置为指定访问的域名header('Access-Control-Allow-Origin:http://www.xxx.com');//如果设置为所有域名都可访问，则会报错header('Access-Control-Allow-Origin:*');//最终配置header('Access-Control-Allow-Origin:http://www.xxx.com');header('Access-Control-Allow-Credentials:true'); 12345678910111213141516171819Node例子//允许跨域传递cookieres.header('Access-Control-Allow-Credentials', true);//这里需要注意必须设置为指定访问的域名res.header('Access-Control-Allow-Origin', 'http://www.xxx.com');//如果设置为所有域名都可访问，则会报错 res.header('Access-Control-Allow-Origin', '*');//最终配置app.all('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', 'http://www.xxx.com'); //Access-Control-Allow-Headers ,可根据浏览器的F12查看,把对应的粘贴在这里就行 res.header('Access-Control-Allow-Headers', 'Content-Type'); res.header('Access-Control-Allow-Methods', 'POST,GET'); res.header('Access-Control-Allow-Credentials', true); res.header('Content-Type', 'application/json;charset=utf-8'); next();&#125;); 对应客户端的 xhrFields.withCredentials: true 参数，服务器端通过在响应 header 中设置 Access-Control-Allow-Credentials = true 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie。这里需要注意的是： 服务器端 Access-Control-Allow-Credentials = true时，参数Access-Control-Allow-Origin 的值不能为 * 。 这里顺便说一下cookie作用域问题。 domain表示的是cookie所在的域，默认为请求的地址如网址为www.jb51.net/test/test.aspx 那么domain默认为www.jb51.net。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。设置是放在ajax请求的位置，加上：123//这里t1.test.com能够访问t2.test.com，进行cookie传递。//t1.test.com不能访问t2.lin.comdocuemnt.cookie = 'domain=test.com'; 主机名是指同一个域下的不同主机，例如：www.google.com 和 gmail.google.com 就是两个不同的主机名。默认情况下，一个主机中创建的cookie在另一个主机下是不能被访问的，但可以通过domain参数来实现对其的控制，其语法格式为：1document.cookie="name=value; domain=cookieDomain"; 以google为例，要实现跨主机访问，可以写为：1document.cookie="name=value;domain=.google.com"; 这样，所有google.com下的主机都可以访问该cookie。 四.vue项目配置跨域在vue项目根目录下config/index.js1234567891011//找到dev配置项，直接添加dev: &#123; proxyTable: &#123; '/user': &#123; target: 'http://localhost:3000/', changeOrigin: true, pathRewrite: &#123; "^/user": '/user' &#125; &#125; &#125; 项目启动端口是8080,请求域名本来是：http://localhost:8080/user，会重定向为http://localhost:3000/userpathRewrite配置项的作用是，将一切/user/xxx等任何请求重定向，同时前端请求地址不用加上主机名，直接/user/xxx就可以。 本篇文章参考文章地址： 关于cookie: https://www.cnblogs.com/Jackie-sky/p/3672544.html cookie跨域：https://blog.csdn.net/qq_21956483/article/details/78720252]]></content>
      <categories>
        <category>ajax跨域请求cookie</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ajax</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网vuejs开发饿了么APP的知识总结]]></title>
    <url>%2F2018%2F12%2F08%2F%E6%85%95%E8%AF%BE%E7%BD%91vuejs%E5%BC%80%E5%8F%91%E9%A5%BF%E4%BA%86%E4%B9%88APP%E7%9A%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[博主博客地址: http://blog.suhuashan.xin本文分为两大模块，第一模块是项目总结，第二模块是知识点归纳。 一.项目总结1.项目源码与浏览项目源代码地址：https://github.com/suhuashan/elm-vue 2.项目打包(npm run build)1.将打包生成的dist文件放在本地或者是服务器，都会出现页面404，访问不到资源的问题，因为是路径问题。 需要修改config下面的index.js这个配置文件里选项assetsPubilcPath: ‘/‘改成‘./’。 再进行打包npm run build，然后再以服务器的形式来访问dist文件的index.html，便能访问。 我在项目根目录写了一个prod.sercer.js文件，然后运行node prod.server.js 这时候项目跑动起来了，访问localhost:9000. 2.因为我是在本地mock数据来模拟后台返回数据，在本地利用express来运行打包后的项目（dist文件夹）还是能够成功返回数据。但是当我把打包后的项目（dist文件夹）上传服务器后，发现数据无法返回。然后上网查了一下，发现自己写的api/seller等接口，是自己为了模拟后台数据而在自己本地写的接口，打包的时候是不会打包上去的，那个是服务端提供的接口，得在服务端写一个同样的接口才行。 然后我为了简便，于是在https://www.easy-mock.com/上面mock数据，就是简单把项目根目录的mockData.json内容写成3个线上接口，分别是： 返回商品数据的接口：https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/goods 返回商家数据的接口：https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/seller 返回评价数据的接口：https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/ratings 将自己项目的里面app.vue，goods.vue，ratings.vue文件里面的请求相应修改（这里举一例，其他类同），将下面本地的请求改成服务器的请求。 1234本地this.$axios.get('/api/goods')服务器this.$axios.get('https://www.easy-mock.com/mock/5b9e72822b292b0e9154c66a/elm/goods') 然后打包后的项目也能够成功在服务器跑起来了。 二.知识点总结下面是对于视频里面出现的几个亮点进行总结： 1.实现移动端细线的效果（如果在移动端直接设置1px的粗线，效果很不美观）(1)方案一（视频里面的方法）： 123456789101112//用media属性在不同手机像素比下显示不同的样式。@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) .border-1px &amp;::after -webkit-transform: scaleY(0.7) transform: scaleY(0.7) @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) .border-1px &amp;::after -webkit-transform: scaleY(0.5) transform: scaleY(0.5) 12345678910111213141516171819202122//项目里面多处用到1px下划线，所以进行抽离为公共的方法border-1px($color) position: relative &amp;:after display: block position: absolute left: 0 bottom: 0 width: 100% border-top: 1px solid $color content: ' '//如果仅仅某处使用到而已.class position: relative &amp;:after display: block position: absolute left: 0 bottom: 0 width: 100% border-top: 1px solid $color content: ' ' （2）方案二（曾经在网上看到的解决方案）： 2.Sticky footer布局实现这个网上已经很多很好的方案了，所以直接上链接 https://www.cnblogs.com/zsqos/archive/2017/06/02/6935646.html 3.移动端滚动better-scrollhttp://www.imooc.com/article/18232 https://github.com/ustbhuangyi/better-scroll 简单来说：当内容的宽度或者高度超过容器的宽高时，这时候就会产生滚动。但是better-scroll初始化一定要在页面DOM渲染完成后才开始计算内容的宽高，否则当内容的宽高大于容器时，无法滚动页面。 解决方案见上面第一个链接。]]></content>
      <categories>
        <category>Vue项目总结</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>慕课网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用指令详细说明]]></title>
    <url>%2F2018%2F12%2F07%2FGit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[博主博客地址: http://blog.suhuashan.xin本文主要讲解git一些常用且实用的操作，方便进行github托管代码。 Git常用命令1.git init1git init //初始当前目录，生成.git文件夹 2.git status1git status //查看当前本地分支下有没有文件被修改或者有没有新增文件 3.git clone123git clone &lt;版本库的网址&gt; git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; // 指定本地目录名git clone -o romoteBranchName &lt;版本库的网址&gt; //指定远程分支名称 clone 命令会创建指定本地目录名的文件夹把版本库的内容更新下来，默认创建本地分支 master 和远程分支 origin /master (这里的origin指的是远程主机名）并绑定；-o 可以指定远程分支名称；不指定本地目录名则创建与版本库目录名一样的目录。 4.git remote123456git remote //命令列出所有远程主机git remote -v //列出所有远程主机并展示远程主机的网址git remote show &lt;主机名&gt; //查看远程分支的详细状况git remote add &lt;主机名&gt; &lt;网址&gt; //添加远程主机名git remote rm &lt;主机名&gt; // 删除远程主机git remote rename &lt;原主机名&gt; &lt;新主机名&gt; // 修改远程主机名 默认远程主机名：origin 5.git branch123git branch //查看本地分支 现在所在的分支会有 * 号标注git branch -r //查看远程分支git branch -a //查看所有分支（本地+远程） 6.git checkout123git checkout 分支名 //切换到指定分支//指定本地分支切出新分支并切换。不指定分支时根据当前分支切新分支git checkout -b newBrach 生成本地新分支 本地和远程默认分支都是master 7.git merge123git checkout 分支名 //切换到指定分支//指定本地分支切出新分支并切换。不指定分支时根据当前分支切新分支git checkout -b newBrach 生成本地新分支 注意:git fetch后当前目录没有任何改变，需要git merge才会得到 可以近似认为：git fetch + git merge = git pull 8.git pull1234//把指定远程主机名远程分支的内容拉取到指定的本地分支git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;//把指定分支内容拉取到当前本地分支，相当于先 fetch 再 mergegit pull &lt;远程主机名&gt; &lt;远程分支名&gt; 注意：默认远程主机名：origin 如果需要自己添加远程主机名，请执行git remote命令 9.git push12345678//把指定本地分支的 commit 推到指定的远程主机远程分支上git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;//把本地分支推送与之存在"追踪关系"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。git push &lt;远程主机名&gt; &lt;远程分支名&gt; //删除指定的远程分支，等同于推送一个空的本地分支到远程分支git push &lt;远程主机名&gt;:&lt;远程分支名&gt;//指定默认主机，下次直接 git push 即可git push -u &lt;远程主机名&gt; &lt;本地分支名&gt; 如果执行git push相关命令后出现下面提示，意味着文件没改变。 参考文章地址： https://git-scm.com/book/zh/v1 http://www.ruanyifeng.com/blog/2014/06/git_remote.html https://blog.csdn.net/weixin_40811829/article/details/84798530]]></content>
      <categories>
        <category>git常用操作</category>
      </categories>
      <tags>
        <tag>git指令</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建博客最全配置]]></title>
    <url>%2F2018%2F09%2F21%2Fhexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%9C%80%E5%85%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[博主博客地址: http://blog.suhuashan.xin本文分为两大模块，第一模块是搭建博客，第二模块是博客主题进行配置，当然我选用的主题是Next。 一.博客搭建1.搭建 Node.js 环境为什么要搭建Node.js环境？ - 因为Hexo博客系统是基于Node.js编写的。 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，可以在非浏览器环境下，解释运行 JS 代码。 在Node.js官网：https://nodejs.org/en/ 下载安装包，推荐下载官方推荐(Recommonded)的版本。 保持默认设置即可，一路Next，安装很快就结束了。 windows打开命令提示符，输入node -v、npm -v出现版本号则说明Node.js环境配置成功，第一步完成！！！ 2.搭建 Git 环境为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上。 Git 是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 在 Git 官网：https://git-scm.com/ 下载安装包，对准自己电脑的操作系统下载一个就可以了 桌面右键，打开 Git Bush Here，输入 git –version，出现版本号则说明 Git 环境配置成功，第二步完成！！！ 3.GitHub 注册和配置GitHub 是一个代码托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。 Github注册：https://github.com/ 注册或者登陆好之后就开始创建仓库。 创建仓库：Repository name 使用自己的用户名。注意：yourname 必须是你的用户名。1yourname/yourname.github.io 访问 yourname.github.io，如果可以正常访问，那么 Github 的配置已经结束了。 到此搭建 Hexo 博客的相关环境配置已经完成，下面开始讲解 Hexo 的相关操作。 4.安装配置 HexoHexo 是一个快速、简洁且高效的博客框架，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 官方文档：https://hexo.io/zh-cn/ 使用 npm 安装 Hexo：在命令行中输入1npm install hexo-cli -g 注意：博主在安装这个包出现管理员权限问题，无法成功安装。于是按 win + x 打开 Window PowerShell,重新安装就可以了，如果安装过程出现WARN，不用担心，因为不会影响正常使用。 查看 Hexo 的版本1hexo version Hexo 安装成功后，在本地创建一个文件夹，文件夹名随意（我命名为blog)，然后鼠标右击该文件夹，按顺序执行下面的命令。123hexo initnpm install 新建完成后，指定文件夹的目录如下：1234567891011.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json #npm 依赖等 运行本地 Hexo 服务123hexo server或者hexo s 您的网站会在 http://localhost:4000 下启动。如果 http://localhost:4000 能够正常访问，则说明 Hexo 本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。 注意1：执行hexo server提示找不到该指令 解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：123sudo npm install hexo-server或者npm install hexo -server --save 5.关联 Hexo 与 GitHub Pages在前面创建的文件夹里面鼠标右键，点击1Git Base Here 将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）12git -config --global user.name "your github name"git -config --global user.email "your email" 接着输入1ssh-keygen -t rsa -C "your email" 连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh或者C:\Users\具体用户.ssh）。 登录 Github，点击头像下的 settings，添加 ssh点击 SSH and GPG keys新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 配置 Deployment 在文件夹的根目录找到_config.yml文件，打开该文件找到Deployment，然后按照如下修改，用户名改成你的信息(需要注意的是：冒号后面记得空一格！)123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:yourname(github的用户名)/yourname.github.io.git branch: master 本地文件提交到 GitHub Pages123456789101112// 删除旧的 public 文件hexo clean// 生成新的 public 文件hexo generate或者hexo g// 开始部署hexo deploye或者hexo d 在浏览器中输入 https://yourname(github的用户名).github.io，你会发现和在本地看到一模一样。 这样，本地 git 项目与远程的 github 建立联系。 6.发表新文章1hexo new "文章标题" //在本地文件夹根目录下输入该命令 在本地博客文件夹 source_posts 文件夹下看到我们新建的 markdown 文件。 当然，我们也可以手动添加Markdown文件在source/post文件夹下，其效果同样可以媲美hexo new指令 文章编辑好之后，运行生成、部署命令： 12345hexo cleanhexo ghexo d 参考链接：https://oakland.github.io/2016/05/02/hexo-%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84post/ 7.GitHub Pages 地址解析到个人域名在 GitHub 仓库的根目录下建立一个 CNAME 的文本文件(注意：没有扩展名)，文件里面只能输入一个你的域名，不能加http://1blog.suhuashan.xin 注意：CNAME 一定是在你 Github 项目的 master 根目录下 进入阿里云域名解析地址，添加解析：12345678910记录类型选择CNAME主机记录填blog //当然填写www也可以，自拟一个吧解析线路选择默认记录值填yourname.github.ioTTL值为10分钟再添加一个解析，记录类型A主机记录填www解析线路选择默认记录值填你GitHub 的ip地址（在cmd中ping：）ping suhuashan.github.io 保存，等待一下访问suhuashan.github.io，域名会重定向为blog.suhuashan.xin 注意：CNAME文件在下次 hexo deploy的时候就消失了，需要重新创建，这样就很繁琐 方法一：每次 hexo d 之后，就去 GitHub 仓库根目录新建 CNAME文件 方法二：在 hexo g 之后， hexo d 之前，把CNAME文件复制到 “\public\” 目录下面，里面写入你要绑定的域名。 方法三（推荐）：将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等，这样在 hexo d 之后就不会被删除了。 二.Hexo的Next主题详细配置这一块我就不多说了，毕竟网上已经有很完美的教程。但是我会提出教程几个讲的比较模糊的地方，然后对不清晰的地方重新配置。 Next 官方文档：http://theme-next.iissnan.com/教程参考(我对网上大部分进行筛选，个人觉得以下这两个比较管用)：https://www.jianshu.com/p/3a05351a37dchttps://zhuanlan.zhihu.com/p/28128674 教程里面需要修改的地方： 1.添加分类模块新建一个分类页面1hexo new page categories 这时候，source文件夹下有了categorcies/index.md，最关键就是要设置type123title: 分类date: 2018-09-20 23:27:47 //按照自己的时间就可以了type: "categories" 打开 主题配置文件 找到menu，将categorcies取消注释 以后写博客直接在文章的 title 下面加上 categorcies 就可以了，例如：123title: 分类测试文章标题categorcies: 测试 //一个类别的情况categorcies: [测试, 验证] //多个类别的情况写成数组 2.添加标签模块新建一个标签页面1hexo new page tags 这时候，source文件夹下有了tags/index.md，最关键就是要设置type123title: 分类date: 2018-09-20 23:27:47 //按照自己的时间就可以了type: "tags" 打开 主题配置文件 找到menu，将tags取消注释 以后写博客直接在文章的 title 下面加上 tags 就可以了，例如：123title: 标签测试文章标题tags: 测试 //一个类别的情况tags: [测试, 验证] //多个类别的情况写成数组 其他配置就按照教程就可以了！]]></content>
      <categories>
        <category>博客搭建教程</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
